Instruction Format
------------------

Type A:
| op |f| rd| ra|  | rb|
|xxxx|x|xxx|xxx|00|xxx|

Type B:
| op |f| rd| ra| imm5|
|xxxx|x|xxx|xxx|xxxxx|

Type C:
| op |f| rd|  imm8  |
|xxxx|x|xxx|xxxxxxxx|


Instruction List
----------------

| Op  | Name    | Type f=0 | Type f=1 | Description          | Operation f=0                    | Operation f=1                       |
| --- | ------- | -------- | -------- | -------------------- | -------------------------------- | ----------------------------------- |
| 0x0 | or      | B        | A        | bitwise or           | rd := ra or imm5                 | rd := ra or rb                      |
| 0x1 | xor     | B        | A        | bitwise xor          | rd := ra xor imm5                | rd := ra xor rb                     |
| 0x2 | and     | B        | A        | bitwise and          | rd := ra and imm5                | rd := ra and rb                     |
| 0x3 | andn    | B        | A        | bitwise and with not | rd := ra and not imm5            | rd := ra and not rb                 |
| 0x4 | add     | B        | A        | integer add          | rd := ra + imm5                  | rd := ra + rb                       |
| 0x5 | sub     | B        | A        | integer sub          | rd := ra - imm5                  | rd := ra - rb                       |
| 0x6 | slt     | B        | A        | set if less          | rd := ra < imm5                  | rd := ra < rb                       |
| 0x7 | sltu    | B        | A        | set if unsigned less | rd := ra < imm5                  | rd := ra < rb                       |
| 0x8 | mul/shl | B        | A        | multiply/shift left  | rd := ra << imm4                 | (rd,ra) := ra * rb                  |
| 0x9 | div/shr | B        | A        | divide/shift right   | rd := ra >> imm4 (logic/arith)   | ra := ra / rb ; rd := ra % rb       |
| 0xa | ld      | B        | C        | load word            | rd := mem[ra + imm5]             | rd := mem[pc + imm8]                |
| 0xb | st      | B        | C        | store word           | mem[ra + imm5] := rd             | mem[pc + imm8] := rd                |
| 0xc | lea     | B        | C        | load address         | rd := ra + imm5                  | rd := pc + imm8                     |
| 0xd | call    | B        | C        | branch and link      | rd := pc+1 ; pc := ra + imm5     | rd := pc+1 ; pc := pc + imm8        |
| 0xe | brnz    | B        | C        | branch if not zero   | pc := ra + imm5 if rd != 0       | pc := pc + imm8 if rd != 0          |
| 0xf | brz     | B        | C        | branch if zero       | pc := ra + imm5 if rd == 0       | pc := pc + imm8 if rd == 0          |


Instruction Encoding
--------------------

| Assembly          | Encoding         | Reads | Writes | Mem | Operation                           |
| ----------------- | ---------------- | ----- | ------ | --- | ----------------------------------- |
| or ra,imm5,rd     | 00000dddaaaiiiii | 1     | 1      |     | rd := ra or imm5                    |
| xor ra,imm5,rd    | 00010dddaaaiiiii | 1     | 1      |     | rd := ra xor imm5                   |
| and ra,imm5,rd    | 00100dddaaaiiiii | 1     | 1      |     | rd := ra and imm5                   |
| andn ra,imm5,rd   | 00110dddaaaiiiii | 1     | 1      |     | rd := ra and not imm5               |
| add ra,imm5,rd    | 01000dddaaaiiiii | 1     | 1      |     | rd := ra + imm5                     |
| sub ra,imm5,rd    | 01010dddaaaiiiii | 1     | 1      |     | rd := ra - imm5                     |
| slt ra,imm5,rd    | 01100dddaaaiiiii | 1     | 1      |     | rd := ra < imm5                     |
| sltu ra,imm5,rd   | 01110dddaaaiiiii | 1     | 1      |     | rd := ra < imm5 (unsigned)          |
| ----------------- | ---------------- | ----- | ------ | --- |------------------------------------ |
| or ra,rb,rd       | 00001dddaaa00bbb | 2     | 1      |     | rd := ra or rb                      |
| xor ra,rb,rd      | 00011dddaaa00bbb | 2     | 1      |     | rd := ra xor rb                     |
| and ra,rb,rd      | 00101dddaaa00bbb | 2     | 1      |     | rd := ra and rb                     |
| andn ra,rb,rd     | 00111dddaaa00bbb | 2     | 1      |     | rd := ra and not rb                 |
| add ra,rb,rd      | 01001dddaaa00bbb | 2     | 1      |     | rd := ra + rb                       |
| sub ra,rb,rd      | 01011dddaaa00bbb | 2     | 1      |     | rd := ra - rb                       |
| slt ra,rb,rd      | 01101dddaaa00bbb | 2     | 1      |     | rd := ra < rb                       |
| sltu ra,rb,rd     | 01111dddaaa00bbb | 2     | 1      |     | rd := ra < rb (unsigned)            |
| ----------------- | ---------------- | ----- | ------ | --- | ----------------------------------- |
| shl ra,imm4,rd    | 10000dddaaa0iiii | 1     | 1      |     | rd := ra << imm4                    |
| shrl ra,imm4,rd   | 10010dddaaa0iiii | 1     | 1      |     | rd := ra >> imm4 (logical)          |
| shra ra,imm4,rd   | 10010dddaaa1iiii | 1     | 1      |     | rd := ra >> imm4 (arithmetic)       |
| mul ra,rb,rd      | 10001dddaaa00bbb | 2     | 2      |     | (rd,ra) := ra * rb                  |
| div ra,rb,rd      | 10011dddaaa00bbb | 2     | 2      |     | ra := ra / rb ; rd := ra % rb       |
| ----------------- | ---------------- | ----- | ------ | --- | ----------------------------------- |
| ld ra+imm5,rd     | 10100dddaaaiiiii | 1     | 1      | r   | rd := mem[ra + imm5]                |
| st ra+imm5,rd     | 10110dddaaaiiiii | 2     | 0      | w   | mem[ra + imm5] := rd                |
| lea ra+imm5,rd    | 11000dddaaaiiiii | 2     | 1      |     | rd := ra + imm5                     |
| call ra+imm5,rd   | 11010dddaaaiiiii | 1     | 1      |     | rd := pc+1 ; pc := ra + imm5        |
| brnz rd,ra+imm5   | 11100dddaaaiiiii | 1     | 0      |     | pc := ra + imm5 if rd != 0          |
| brz rd,ra+imm5    | 11110dddaaaiiiii | 1     | 0      |     | pc := ra + imm5 if rd == 0          |
| ----------------- | ---------------- | ----- | ------ | --- | ----------------------------------- |
| ld imm8,rd        | 10101dddiiiiiiii | 0     | 1      | r   | rd := mem[pc + imm8]                |
| st imm8,rd        | 10111dddiiiiiiii | 1     | 0      | w   | mem[pc + imm8] := rd                |
| lea imm8,rd       | 11001dddiiiiiiii | 1     | 1      |     | rd := pc + imm8                     |
| call imm8,rd      | 11011dddiiiiiiii | 0     | 1      |     | rd := pc+1 ; pc := pc + imm8        |
| brnz rd,imm8      | 11101dddiiiiiiii | 1     | 0      |     | pc := pc + imm8 if rd != 0          |
| brz rd,imm8       | 11111dddiiiiiiii | 1     | 0      |     | pc := pc + imm8 if rd == 0          |
| ----------------- | ---------------- | ----- | ------ | --- | ----------------------------------- |
| set imm5,rd       | 00000ddd111iiiii | 1     | 1      |     | rd := imm5                          |
| mov ra,rd         | 00000dddaaa00000 | 1     | 1      |     | rd := ra                            |
| not ra,rd         | 00010dddaaa11111 | 1     | 1      |     | rd := not ra                        |
| neg ra,rd         | 01011ddd11100aaa | 2     | 1      |     | rd := neg ra                        |
| snz ra,rd         | 01110dddaaa00001 | 2     | 1      |     | rd := r == 0                        |
| sz ra,rd          | 01111ddd11100aaa | 2     | 1      |     | rd := r != 0                        |
| br ra+imm5        | 11010111aaaiiiii | 1     | 1      |     | pc := ra + imm5                     |
| br imm8           | 11011111iiiiiiii | 0     | 1      |     | pc := pc + imm8                     |
| ----------------- | ---------------- | ----- | ------ | --- | ----------------------------------- |
| nop               | 0000000000000000 | 1     | 1      |     | skip instruction                    |
| halt              | 1111111111111111 | 1     | 0      |     | stop the processor                  |
| ----------------- | ---------------- | ----- | ------ | --- |------------------------------------ |
